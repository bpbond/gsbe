---
title: "gsbe-data"
author: "bbl"
format:
  html:
    code-fold: true
toc: true
editor: visual
---

```{r setup}
#| include: false

library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())
library(readr)
library(lubridate)

dat <- read_csv("srdb_joined_data.csv", show_col_types = FALSE)

message(nrow(dat), " rows of data")

dat %>% 
    filter(is.na(Rs_growingseason) | (Rs_growingseason > 0 & Rs_growingseason < 20)) %>% 
    filter(is.na(Rs_annual) | (Rs_annual > 0 & Rs_annual < 4000)) %>% 
    filter(is.na(Rh_annual) | (Rh_annual > 0 & Rh_annual < 2000)) %>% 
    replace_na(list(Ecosystem_type = "Unknown", Biome = "Unknown")) ->
    dat_filtered

message("After filtering, ", nrow(dat_filtered), " rows of data")

```

## *Independent variable distribution*

*We have three potential independent variables – `Rs_annual` (annual soil respiration), `Rh_annual` (annual heterotrophic respiration), and `Rs_growingseason` (mean growing season soil respiration) – and their distributions are non-normal.*

```{r}
#| fig-width: 10
#| fig-height: 8

dat_filtered %>% 
    select(Rs_annual, Rh_annual, Rs_growingseason) %>% 
    pivot_longer(everything()) %>% 
    filter(!is.na(value), value > 0) %>% 
    rename(none = value) %>% 
    mutate(log = log(none), sqrt = sqrt(none)) %>% 
    
    pivot_longer(-name, names_to = "Transformation") %>% 
    ggplot(aes(value, color = Transformation)) + 
    geom_density() +
    facet_wrap(~ name + Transformation, scales = "free")

dat_filtered %>% 
    mutate(sqrt_Rs_annual = sqrt(Rs_annual),
           sqrt_Rh_annual = sqrt(Rh_annual),
           sqrt_Rs_growingseason = sqrt(Rs_growingseason)) ->
    dat_filtered

```

*We have a transformation winner: `sqrt()`!*

## *Dataset overview*

```{r read-data}
#| fig-width: 10
#| fig-height: 8

dat_filtered %>% 
    select(Biome, Ecosystem_type, sqrt_Rs_annual, sqrt_Rh_annual, sqrt_Rs_growingseason,
           Tair, Tsoil_lev1, VWC_lev1, Precip, LAI_high, 
           MODIS_NPP, MODIS_GPP) %>% 
    pivot_longer(Tair:MODIS_GPP, names_to = "covariate_name", values_to = "covariate_value") %>%
    pivot_longer(sqrt_Rs_annual:sqrt_Rs_growingseason) %>% 
    ggplot(aes(value, covariate_value, color = Biome)) + 
        facet_grid(covariate_name ~ name, scales = "free") +
        geom_point(na.rm = TRUE)

dat_filtered %>% 
    filter(!Biome == "Semi-arid", !Biome == "Unknown") %>% 
    select(Biome, Ecosystem_type, sqrt_Rs_annual, 
           Tair, Tsoil_lev1, VWC_lev1, Precip, LAI_high) %>% 
    pivot_longer(Tair:LAI_high, names_to = "covariate_name", values_to = "covariate_value") %>% 
    ggplot(aes(sqrt_Rs_annual, covariate_value, color = Biome)) + 
        facet_grid(covariate_name ~ Biome, scales = "free") +
        geom_point(na.rm = TRUE)
 
stn <- as.factor(dat_filtered$Soil_type_number)
nst <- length(unique(stn))
dat_filtered %>% 
    select(sqrt_Rs_growingseason, sqrt_Rs_annual, sqrt_Rh_annual) %>% 
    pairs(col = hcl.colors(nst, "Temps")[stn])

```

## *Test Random Forest model*

```{r test-rf}

# Fit random forest model; i.v. in first column
library(ranger)
fit_and_test_rf <- function(x_train, x_val) {
    f <- as.formula(paste(colnames(x_train)[1], "~ ."))
    rf <- ranger::ranger(formula = f, data = x_train, importance = "impurity")
    # use importance = "permutation" for importance_pvalues()
    
    preds <- predict(rf, data = x_val)$predictions
    obs <- pull(x_val[1])
    rss <- sum((preds - obs) ^ 2)
    tss <- sum((obs - mean(obs)) ^ 2)

    return(list(model = rf,
                training_r2 = rf$r.squared, 
                importance = importance(rf), 
                validation_r2 = 1 - rss / tss))
} # fit random forest model

dat_filtered %>% 
    select(sqrt_Rs_annual, Longitude, Latitude,
           Ecosystem_type, SPEI12, #MODIS_NPP, MODIS_GPP,
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> test


# ======================== Testing spatial RF
# This needs the newest version 1.1.5, not yet on CRAN
# remotes::install_github(
#   repo = "blasbenito/spatialRF",
#   ref = "main",
#   force = TRUE,
#   quiet = TRUE
#   )

dm <- geodist::geodist(select(test, Longitude, Latitude), measure = "geodesic")
test$Longitude <- test$Latitude <- NULL

rf_sp <- spatialRF::rf(data = test, 
                       dependent.variable.name = colnames(test)[1],
                       predictor.variable.names = setdiff(colnames(test), colnames(test)[1]),
                       distance.matrix = dm,
                       distance.thresholds = 0)
print(rf_sp)
# ======================== Testing spatial RF



message("The test complete-cases dataset has ", dim(test)[1], " rows and ", dim(test)[2], " columns")
set.seed(123)
groups <- sample.int(n = 10, size = nrow(test), replace = TRUE)
test_train <- test[groups != 1,]
test_val <- test[groups == 1,]
message("The test training dataset has ", dim(test_train)[1], " rows and ", dim(test_train)[2], " columns")
message("The test validation dataset has ", dim(test_val)[1], " rows and ", dim(test_val)[2], " columns")

test_out <- fit_and_test_rf(x_train = test_train, x_val = test_val)
print(test_out)
imp <- tibble(vars = names(test_out$importance), vals = test_out$importance)

#library(vivid)
# This doesn't work with character predictors though
#pdpVars(test, rf, "Rs_annual")
```

## *Analysis1*

```{r}
#| eval: false


fit_lm <- function(x) {} # fit linear model; i.v. in first column

do_k_fold <- function(x, k = 10) {
    if(!all(complete.cases(x))) {
        stop("x should not have any NAs at this stage!")
    }
    
    set.seed(123)
    groups <- sample.int(n = k, size = nrow(x), replace = TRUE)
    training_r2 <- rep.int(NA_real_, k)
    validation_r2 <- rep.int(NA_real_, k)
    for(i in seq_len(k)) {
        x_val <- x[groups == i,]
        x_train <- x[groups != i,]
        message("\tk-fold ", i, ":")
        message("\t\tTraining is ", nrow(x_train), " x ", ncol(x_train))
        message("\t\tValidation is ", nrow(x_val), " x ", ncol(x_val))

        rf_out <- fit_and_test_rf(x_train = x_train, x_val = x_val)
        training_r2[i] <- rf_out$training_r2
        validation_r2[i] <- rf_out$validation_r2
        
        message("\t\tTraining R2 = ", round(training_r2[i], 3))
        message("\t\tValidation R2 = ", round(validation_r2[i], 3))
    }
    tibble(k = seq_len(k), 
           training_r2 = training_r2,
           validation_r2 = validation_r2)
} # compute fit statistics using k-fold


# compute distances between points if using spatial RF
# fit ranger::ranger() or spatialRF::rf()

# These are the three most common fluxes recorded in SRDB
iv_set <- c("Rs_annual")#, "Rh_annual", "Rs_growingseason")
#iv_set <- c("sqrt_Rs_annual", "sqrt_Rh_annual", "sqrt_Rs_growingseason")

# The following SPI values are from Table 1 of Keune et al. (2025)
# https://www.nature.com/articles/s41597-025-04896-y
# and correspond to "severely dry", "moderately dry", and "mildly dry"
# (there are no "extremely dry"=-2 in the dataset)
spei_cutoffs <- c(-1.5, -1.0, 0.0)

# What SPEI window should be used for the cutoffs above?
spei_windows <- c(12, 24) # months

# Model independent variables
predictors <- c(#"Longitude", "Latitude", # hmmmmm
                "Ecosystem_type",
                "SPEI12",
               # "MODIS_NPP", "MODIS_GPP",
                "Tair", "Precip",
                "Tsoil_lev1", "Tsoil_lev2", "VWC_lev1", "VWC_lev2", 
                "LAI_high", "Soil_type_name")

set.seed(123)
do_full_analysis <- function(x, iv_set, predictors, spei_windows, spei_cutoffs, k = 10) {
    results <- list()
    SPEI_cols <- colnames(x)[grep("^SPEI", colnames(x))]
    for(iv in iv_set) {
        
        for(w in spei_windows) {
            spei_past_col <- paste0("SPEI", w, "_y1")
            
            for(spei_cut in spei_cutoffs) {
                            # Remove other potential independent variables
            this_x <- x[c(iv, union(predictors, SPEI_cols))]
            # Complete cases only
            this_x <- this_x[complete.cases(this_x),]
            
                message("---------------------------------------------")
                message("iv = ", iv)
                message("spei_cut = ", spei_cut, " window = ", w)
                message("\tn = ", nrow(this_x))
                
                # identify observations not currently in a drought but that
                # WERE in a drought the previous year
                # PBE = potential Birch effect
                this_x$PBE = this_x$SPEI12 > 0 & this_x[spei_past_col] <= spei_cut
                message("\tPBE = ", sum(this_x$PBE))
                
                # Drop non-predictors entirely now
                this_x <- this_x[c(iv, predictors, "PBE")]
                
                # Run the k-fold and save results
                k_fold_out <- do_k_fold(this_x, k = k)
                k_fold_out$spei_window = w
                k_fold_out$spei_cut <- spei_cut
                k_fold_out$iv = iv
                results[[paste(iv, w, spei_cut)]] <- k_fold_out
            }
        }
    }
    bind_rows(results)
}

out <- do_full_analysis(dat_filtered,
                        iv_set, predictors,
                        spei_windows = c(12,24),
                        spei_cutoffs = spei_cutoffs,
                        k = 3)


# rescale predictors
# complete.cases
# compute variable inflation or other correlated predictors metric

# loop over iv_set and spei_cutoff_values:


# - compute PBE flag
    dat_filtered %>% 
        # identify observations not in a drought but WERE in a drought
        # PBE = potential Birch effect
        mutate(PBE = SPEI12 > 0 & SPEI12_y1 <= -1) ->
        dat_pbe
# - for each model type
# --- fit model and calculate PBE effect
# --- call do_k_fold
# --- save fit data associated with this iv and cutoff value

m <- lm(sqrt_Rs_annual ~ Tair + Tsoil_lev1 + Tsoil_lev2 + 
            VWC_lev1 + I(VWC_lev1 ^ 2) + VWC_lev2 ^ 2 + I(VWC_lev2 ^ 2) + 
            MODIS_GPP + MODIS_NPP + 
            Ecosystem_type * PBE, 
        data = dat_pbe)
m_reduced <- MASS::stepAIC(m, trace = FALSE)
summary(m_reduced)

library(car)
car::Anova(m_reduced, type = "III")
```

## *Reproducibility*

```{r}
#| echo: false

sessionInfo()
```
