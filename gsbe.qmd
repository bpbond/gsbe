---
title: "gsbe"
author: "bbl"
format:
  html:
    code-fold: true
toc: true
editor: visual
---

```{r setup}
#| include: false

library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())
library(readr)
library(lubridate)

```

```{r read-data}

SSD <- 123
message("set.seed = ", SSD)
set.seed(SSD)

dat <- read_csv("srdb_joined_data.csv", show_col_types = FALSE)

message(nrow(dat), " rows of data")

dat %>% 
    filter(is.na(Rs_growingseason) | (Rs_growingseason > 0 & Rs_growingseason < 20)) %>% 
    filter(is.na(Rs_annual) | (Rs_annual > 0 & Rs_annual < 4000)) %>% 
    filter(is.na(Rh_annual) | (Rh_annual > 0 & Rh_annual < 2000)) %>% 
    replace_na(list(Ecosystem_type = "Unknown", Biome = "Unknown")) ->
    dat_filtered

message("After filtering, ", nrow(dat_filtered), " rows of data")
```

## Independent variable distribution

We have three potential independent variables:

-   `Rs_annual` (annual soil respiration)

-   `Rh_annual` (annual heterotrophic respiration)

-   `Rs_growingseason` (mean growing season soil respiration)

Their distributions are expected to be non-normal, which is a problem for linear models and not ideal for anything. Evaluate possible transformations.

```{r}
#| fig-width: 10
#| fig-height: 8

dat_filtered %>% 
    select(Rs_annual, Rh_annual, Rs_growingseason) %>% 
    pivot_longer(everything()) %>% 
    filter(!is.na(value), value > 0) %>% 
    rename(none = value) %>% 
    mutate(log = log(none), sqrt = sqrt(none)) %>% 
    
    pivot_longer(-name, names_to = "Transformation") %>% 
    ggplot(aes(value, color = Transformation)) + 
    geom_density() +
    facet_wrap(~ name + Transformation, scales = "free")

dat_filtered %>% 
    mutate(sqrt_Rs_annual = sqrt(Rs_annual),
           sqrt_Rh_annual = sqrt(Rh_annual),
           sqrt_Rs_growingseason = sqrt(Rs_growingseason)) ->
    dat_filtered

```

We have a transformation winner: `sqrt()`!

## Dataset overview

```{r prep-data}
#| fig-width: 10
#| fig-height: 8

dat_filtered %>% 
    select(Biome, Ecosystem_type, sqrt_Rs_annual, sqrt_Rh_annual, sqrt_Rs_growingseason,
           Tair, Tsoil_lev1, VWC_lev1, Precip, LAI_high, 
           MODIS_NPP, MODIS_GPP) %>% 
    pivot_longer(Tair:MODIS_GPP, names_to = "covariate_name", values_to = "covariate_value") %>%
    pivot_longer(sqrt_Rs_annual:sqrt_Rs_growingseason) %>% 
    ggplot(aes(value, covariate_value, color = Biome)) + 
        facet_grid(covariate_name ~ name, scales = "free") +
        geom_point(na.rm = TRUE)

dat_filtered %>% 
    filter(!Biome == "Semi-arid", !Biome == "Unknown") %>% 
    select(Biome, Ecosystem_type, sqrt_Rs_annual, 
           Tair, Tsoil_lev1, VWC_lev1, Precip, LAI_high) %>% 
    pivot_longer(Tair:LAI_high, names_to = "covariate_name", values_to = "covariate_value") %>% 
    ggplot(aes(sqrt_Rs_annual, covariate_value, color = Biome)) + 
        facet_grid(covariate_name ~ Biome, scales = "free") +
        geom_point(na.rm = TRUE)
 
stn <- as.factor(dat_filtered$Soil_type_number)
nst <- length(unique(stn))
dat_filtered %>% 
    select(sqrt_Rs_growingseason, sqrt_Rs_annual, sqrt_Rh_annual) %>% 
    pairs(col = hcl.colors(nst, "Temps")[stn])

```

## Test Random Forest model

We are using the `ranger` package.

Wright, M. N. and Ziegler, A.: Ranger: A fast implementation of random forests for high dimensional data in C++ and R, J. Stat. Softw., 77, https://doi.org/10.18637/jss.v077.i01, 2017.

```{r test-rf}
#| fig-width: 10
#| fig-height: 6

# Fit random forest model; i.v. in first column
library(ranger)
fit_and_test_rf <- function(x_train, x_val) {
    f <- as.formula(paste(colnames(x_train)[1], "~ ."))
    rf <- ranger::ranger(formula = f, data = x_train, importance = "impurity")
    # use importance = "permutation" for importance_pvalues()
    
    preds <- predict(rf, data = x_val)$predictions
    obs <- pull(x_val[1])
    rss <- sum((preds - obs) ^ 2)
    tss <- sum((obs - mean(obs)) ^ 2)

    return(list(model = rf,
                training_r2 = rf$r.squared, 
                importance = importance(rf), 
                validation_r2 = 1 - rss / tss))
} # fit random forest model

dat_filtered %>% 
    # vivid::pdpVars() below needs things as factors not char
    mutate(Ecosystem_type = as.factor(Ecosystem_type),
           Soil_type_name = as.factor(Soil_type_name),
           PBE = SPEI12_y1 <= -1 & SPEI12 > 0) %>% 
    select(sqrt_Rs_annual, #Longitude, Latitude,
           Ecosystem_type, SPEI12, PBE, 
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test

message("The test complete-cases dataset has ", dim(test)[1],
        " rows and ", dim(test)[2], " columns")
message("Fitting all-data model")
rf_all_data <- ranger(sqrt_Rs_annual ~ ., data = test, importance = "impurity")
print(rf_all_data)

imps <- sort(rf_all_data$variable.importance, decreasing = TRUE)

library(vivid)
# Top three variables...
pdpVars(data = test, 
        fit = rf_all_data, 
        response = "sqrt_Rs_annual",
        vars = names(imps)[1:3])
# ...and the next three
pdpVars(data = test, 
        fit = rf_all_data, 
        response = "sqrt_Rs_annual",
        vars = names(imps)[4:6])


# Fit a model without PBE and compare
rf_all_data_no_PBE <- ranger(sqrt_Rs_annual ~ ., 
                             data = select(test, -PBE),
                             importance = "impurity")

tibble(model_with_PBE =rf_all_data$predictions,
       model_without_PBE = rf_all_data_no_PBE$predictions,
       PBE = test$PBE) %>% 
    ggplot(aes(model_without_PBE, model_with_PBE)) + 
    geom_point(aes(color = PBE)) + 
    geom_abline() + 
    ggtitle("Random Forest: effect of including PBE")
```

## How important are the MODIS data?

The MODIS data only start in 2001 (see `gsbe-data-prep` output), so requiring them in a model cuts off a lot of early data â€“ on the order of 20%. Are they needed?

```{r}
dat_filtered %>% 
    select(sqrt_Rs_annual,
           Ecosystem_type, SPEI12, MODIS_NPP, MODIS_GPP,
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test1
rf_modis <- ranger(sqrt_Rs_annual ~ ., data = test1)

dat_filtered %>% 
    select(sqrt_Rs_annual, Longitude, Latitude,
           Ecosystem_type, SPEI12, #MODIS_NPP, MODIS_GPP,
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test2
rf_no_modis <- ranger(sqrt_Rs_annual ~ ., data = test1)

message("Model *with* MODIS data OOB R2 = ", round(rf_modis$r.squared, 4))
message("Model *without* MODIS data OOB R2 = ", round(rf_no_modis$r.squared, 4))

```

It doesn't seem like they're needed.

## Test spatial Random Forest

Spatial autocorrelation wouldn't change the fit of the model, but it could bias the variable importance metrics. Evaluate.

```{r spatial-rf}

# This needs the newest version 1.1.5, not yet on CRAN
# remotes::install_github(repo = "blasbenito/spatialRF",
#   ref = "main", force = TRUE, quiet = TRUE)
stopifnot(packageVersion("spatialRF") >= "1.1.5")

dat_filtered %>% 
    select(sqrt_Rs_annual, Longitude, Latitude,
           Ecosystem_type, SPEI12, #MODIS_NPP, MODIS_GPP,
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test

# Compute distance between all pairs of points
library(geodist)
dm <- geodist(select(test, Longitude, Latitude), measure = "geodesic")
test$Longitude <- test$Latitude <- NULL

library(spatialRF)
rf_sp <- spatialRF::rf(data = test, 
                       dependent.variable.name = colnames(test)[1],
                       predictor.variable.names = setdiff(colnames(test), colnames(test)[1]),
                       distance.matrix = dm)
```

## Analysis1

```{r analysis1}
#| eval: true


fit_lm <- function(x) {} # fit linear model; i.v. in first column

do_k_fold <- function(x, k = 10) {
    if(!all(complete.cases(x))) {
        stop("x should not have any NAs at this stage!")
    }
    
    set.seed(123)
    groups <- sample.int(n = k, size = nrow(x), replace = TRUE)
    training_r2 <- rep.int(NA_real_, k)
    validation_r2 <- rep.int(NA_real_, k)
    for(i in seq_len(k)) {
        x_val <- x[groups == i,]
        x_train <- x[groups != i,]
        # message("\tk-fold ", i, ":")
        # message("\t\tTraining is ", nrow(x_train), " x ", ncol(x_train))
        # message("\t\tValidation is ", nrow(x_val), " x ", ncol(x_val))

        rf_out <- fit_and_test_rf(x_train = x_train, x_val = x_val)
        training_r2[i] <- rf_out$training_r2
        validation_r2[i] <- rf_out$validation_r2
        
        # message("\t\tTraining R2 = ", round(training_r2[i], 3))
        # message("\t\tValidation R2 = ", round(validation_r2[i], 3))
    }
    tibble(k = seq_len(k), 
           training_r2 = training_r2,
           validation_r2 = validation_r2)
} # compute fit statistics using k-fold



# These are the three most common fluxes recorded in SRDB
#iv_set <- c("Rs_annual")#, "Rh_annual", "Rs_growingseason")
iv_set <- c("sqrt_Rs_annual", "sqrt_Rh_annual", "sqrt_Rs_growingseason")

# The following SPEI values are from Table 1 of Keune et al. (2025)
# https://www.nature.com/articles/s41597-025-04896-y
# and correspond to "severely dry", "moderately dry", and "mildly dry"
# (there are no "extremely dry"=-2 in the dataset)
spei_cutoffs <- c(-1.5, -1.0, 0.0)

# What SPEI window should be used for the cutoffs above?
spei_windows <- c(12, 24) # months

# Model independent variables
predictors <- c("Ecosystem_type",
                "SPEI12",
                "Tair", "Precip",
                "Tsoil_lev1", "Tsoil_lev2", "VWC_lev1", "VWC_lev2", 
                "LAI_high", "Soil_type_name")

do_full_analysis <- function(x, iv_set, predictors, spei_windows, spei_cutoffs, k = 10) {
    results <- list()
    SPEI_cols <- colnames(x)[grep("^SPEI", colnames(x))]
    for(iv in iv_set) {
        
        for(w in spei_windows) {
            spei_past_col <- paste0("SPEI", w, "_y1")
            
            for(spei_cut in spei_cutoffs) {
                # Remove other potential independent variables
                this_x <- x[c(iv, union(predictors, SPEI_cols))]
                # Complete cases only
                this_x <- this_x[complete.cases(this_x),]
                
                message("---------------------------------------------")
                message("iv = ", iv)
                message("spei_cut = ", spei_cut, " window = ", w)
                message("\tn = ", nrow(this_x))
                
                # identify observations not currently in a drought but that
                # WERE in a drought the previous year
                # PBE = potential Birch effect
                this_x$PBE = this_x$SPEI12 > 0 & this_x[spei_past_col] <= spei_cut
                message("\tPBE = ", sum(this_x$PBE))
                
                # Drop non-predictors entirely now
                this_x <- this_x[c(iv, predictors, "PBE")]
                
                # Run the k-fold and save results
                k_fold_out <- do_k_fold(this_x, k = k)
                k_fold_out$spei_window = w
                k_fold_out$spei_cut <- spei_cut
                k_fold_out$iv = iv
                results[[paste(iv, w, spei_cut)]] <- k_fold_out
            }
        }
    }
    bind_rows(results)
}

out <- do_full_analysis(dat_filtered,
                        iv_set, predictors,
                        spei_windows = c(12,24),
                        spei_cutoffs = spei_cutoffs,
                        k = 10)

# Compute means across the k-folds
out %>% 
    group_by(spei_window, spei_cut, iv) %>% 
    summarise(training_r2 = mean(training_r2), 
              validation_r2 = mean(validation_r2)) %>% 
    mutate(spei_cut = as.factor(spei_cut),
           spei_window = paste(spei_window, "months")) ->
    out_smry

ggplot(out_smry, aes(spei_cut, iv, fill = validation_r2)) + 
    geom_tile() + 
    facet_wrap(~spei_window) +
    xlab("Previous-year SPEI cutoff") + ylab("")

out_smry %>% 
    filter(spei_window == "12 months") %>% 
    pivot_longer(cols = c(training_r2, validation_r2)) %>% 
    ggplot(aes(spei_cut, iv, fill = value)) +
    geom_tile() +
    facet_wrap(~name) +
    xlab("Previous-year SPEI cutoff") + ylab("") +
    ggtitle("12-month SPEI window")

```

## Test linear model

```{r test-linear}

dat_filtered %>% 
    mutate(Ecosystem_type = as.factor(Ecosystem_type),
           Soil_type_name = as.factor(Soil_type_name),
           PBE = SPEI12_y1 <= -1 & SPEI12 > 0) %>% 
    select(sqrt_Rs_annual, #Longitude, Latitude,
           Ecosystem_type, SPEI12, PBE, 
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    dat_linear

message("Fitting linear model with PBE (SPEI12, -1.0) effect...")
m <- lm(sqrt_Rs_annual ~ (Tair + Tsoil_lev1 + Tsoil_lev2 +
            VWC_lev1 + I(VWC_lev1 ^ 2) + VWC_lev2 ^ 2 + I(VWC_lev2 ^ 2)) * PBE +
            Ecosystem_type,
        data = dat_linear)
m_reduced <- MASS::stepAIC(m, trace = FALSE)
summary(m_reduced)
par(mfrow = c(2, 2))
plot(m_reduced)

library(car)
car::Anova(m_reduced, type = "III")

message("Fitting linear model without PBE effect...")
m_no_PBE <- lm(sqrt_Rs_annual ~ (Tair + Tsoil_lev1 + Tsoil_lev2 +
            VWC_lev1 + I(VWC_lev1 ^ 2) + VWC_lev2 ^ 2 + I(VWC_lev2 ^ 2)) +
            Ecosystem_type,
        data = dat_linear)
m_no_PBE_reduced <- MASS::stepAIC(m, trace = FALSE)

tibble(model_with_PBE = predict(m),
       model_without_PBE = predict(m_no_PBE),
       PBE = dat_linear$PBE) %>% 
    ggplot(aes(model_without_PBE, model_with_PBE)) + 
    geom_point(aes(color = PBE)) + 
    geom_abline() + 
    ggtitle("Linear model: effect of including PBE")

```

## Reproducibility

```{r}
#| echo: false

sessionInfo()
```
