---
title: "gsbe"
author: "bbl"
format:
  html:
    code-fold: true
toc: true
editor: visual
---

```{r setup}
#| include: false

# Data processing and visualization packages
library(dplyr)
library(tidyr)
library(ggplot2)
theme_set(theme_bw())
library(readr)
library(lubridate)

# Main analysis packages
library(ranger)
library(vivid)
library(broom)
library(car)

# Specialized packages used only for testing alternatives
library(party)
library(xgboost)
library(geodist)
library(spatialRF)
```

```{r read-data}

SSD <- 123
message("set.seed = ", SSD)
set.seed(SSD)

dat <- read_csv("srdb_joined_data.csv", show_col_types = FALSE)

message(nrow(dat), " rows of data")

dat %>% 
    filter(is.na(Rs_growingseason) | (Rs_growingseason > 0 & Rs_growingseason < 20)) %>% 
    filter(is.na(Rs_annual) | (Rs_annual > 0 & Rs_annual < 4000)) %>% 
    filter(is.na(Rh_annual) | (Rh_annual > 0 & Rh_annual < 2000)) %>% 
    # most SRDB records are from forests (~3000), then grasslands (~760), 
    # ag (~540), shrubland (~230), wetland (~210), and desert (~80). We add
    # the next one, savanna (~30), because it might be particularly 
    # vulnerable to a Birch effect, but group everything else into "Other"
    mutate(Ecosystem_type = if_else(Ecosystem_type %in% c("Agriculture", "Desert",
                                                          "Forest", "Grassland",
                                                          "Savanna", "Shrubland", "Wetland"),
                                    Ecosystem_type, "Other"),
           Ecosystem_type = as.factor(Ecosystem_type),
           Soil_type_name = as.factor(Soil_type_name)) ->
    dat_filtered

message("After filtering, ", nrow(dat_filtered), " rows of data")
```

## Independent variable distribution

We have three potential independent variables:

-   `Rs_annual` (annual soil respiration)

-   `Rh_annual` (annual heterotrophic respiration)

-   `Rs_growingseason` (mean growing season soil respiration)

Their distributions are expected to be non-normal, which is a problem for linear models and not ideal for anything. Evaluate possible transformations.

```{r}
#| fig-width: 10
#| fig-height: 8

dat_filtered %>% 
    select(Rs_annual, Rh_annual, Rs_growingseason) %>% 
    pivot_longer(everything()) %>% 
    filter(!is.na(value), value > 0) %>% 
    rename(none = value) %>% 
    mutate(log = log(none), sqrt = sqrt(none)) %>% 
    
    pivot_longer(-name, names_to = "Transformation") %>% 
    ggplot(aes(value, color = Transformation)) + 
    geom_density() +
    facet_wrap(~ name + Transformation, scales = "free")

dat_filtered %>% 
    mutate(sqrt_Rs_annual = sqrt(Rs_annual),
           sqrt_Rh_annual = sqrt(Rh_annual),
           sqrt_Rs_growingseason = sqrt(Rs_growingseason)) ->
    dat_filtered

```

**Conclusion: we have a transformation winner: `sqrt()`!**

## Random Forest model: performance

We are using the `ranger` package.

Wright, M. N. and Ziegler, A.: Ranger: A fast implementation of random forests for high dimensional data in C++ and R, J. Stat. Softw., 77, https://doi.org/10.18637/jss.v077.i01, 2017.

```{r test-rf}
#| fig-width: 10
#| fig-height: 6

# Fit random forest model and test against validation data
# The i.v. is in the first column
fit_and_test_rf <- function(x_train, x_val) {
    f <- as.formula(paste(colnames(x_train)[1], "~ ."))
    rf <- ranger::ranger(formula = f, data = x_train, importance = "impurity")
    # use importance = "permutation" for importance_pvalues()
    
    if(!is.null(x_val)) {
        preds <- predict(rf, data = x_val)$predictions
        obs <- pull(x_val[1])
        rss <- sum((preds - obs) ^ 2)
        tss <- sum((obs - mean(obs)) ^ 2)
        validation_r2 <- 1 - rss / tss
    } else {
        validation_r2 <- NA_real_
    }

    return(list(model = rf,
                training_r2 = rf$r.squared, 
                importance = importance(rf), 
                validation_r2 = validation_r2))
}

dat_filtered %>% 
    # vivid::pdpVars() below needs things as factors not char
    mutate(Ecosystem_type = as.factor(Ecosystem_type),
           Soil_type_name = as.factor(Soil_type_name),
           PBE = SPEI12_y1 <= -1 & SPEI12 > 0) %>% 
    select(sqrt_Rs_annual, #Longitude, Latitude,
           SPEI12, PBE, 
           Tair, Tsoil_lev1, Tsoil_lev2,
           Precip, VWC_lev1, VWC_lev2, 
           LAI_high, LAI_low, Ecosystem_type,
           Veg_type_hi, Veg_type_low, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test

message("The test complete-cases dataset has ", dim(test)[1],
        " rows and ", dim(test)[2], " columns")
message("Fitting all-data model")
rf_all_data <- ranger(sqrt_Rs_annual ~ ., data = test, importance = "impurity")
print(rf_all_data)

imps <- sort(rf_all_data$variable.importance, decreasing = TRUE)

# Top three variables...
pdpVars(data = test, 
        fit = rf_all_data, 
        response = "sqrt_Rs_annual",
        vars = names(imps)[1:3])
# ...and the next three
pdpVars(data = test, 
        fit = rf_all_data, 
        response = "sqrt_Rs_annual",
        vars = names(imps)[4:6])


# Fit a model without PBE and compare
rf_all_data_no_PBE <- ranger(sqrt_Rs_annual ~ ., 
                             data = select(test, -PBE),
                             importance = "impurity")

tibble(model_with_PBE =rf_all_data$predictions,
       model_without_PBE = rf_all_data_no_PBE$predictions,
       PBE = test$PBE,
       Ecosystem_type = test$Ecosystem_type) %>% 
    ggplot(aes(model_without_PBE, model_with_PBE)) + 
    geom_point(aes(color = PBE)) + 
    geom_abline() + 
    facet_wrap(~Ecosystem_type) +
    ggtitle("Random Forest: effect of including PBE")
```

## How important are the MODIS data?

The MODIS data only start in 2001 (see `gsbe-data-prep` output), so requiring them in a model cuts off a lot of early data – on the order of 20% of the dataset. Are they needed?

```{r}
dat_filtered %>% 
    select(sqrt_Rs_annual,
           Ecosystem_type, SPEI12, MODIS_NPP, MODIS_GPP,
           Tair:LAI_high, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test1
rf_modis <- ranger(sqrt_Rs_annual ~ ., data = test1)

dat_filtered %>% 
    select(sqrt_Rs_annual, Longitude, Latitude,
           Ecosystem_type, SPEI12, #MODIS_NPP, MODIS_GPP,
           Tair:LAI_low, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test2
rf_no_modis <- ranger(sqrt_Rs_annual ~ ., data = test1)

message("Model *with* MODIS data OOB R2 = ", round(rf_modis$r.squared, 4))
message("Model *without* MODIS data OOB R2 = ", round(rf_no_modis$r.squared, 4))

```

**Conclusion: it doesn't seem like they're needed.**

## Conditional inference Random Forest

> Recall the default splitting rule during random forests tree building consists of selecting, out of all splits of the (randomly selected *mtry*) candidate variables, the split that minimizes the Gini impurity (in the case of classification) and the SSE (in case of regression). **However, \[Strobl et al. (2007)\](**<https://doi.org/10.1186/1471-2105-8-25>**) illustrated that these default splitting rules favor the selection of features with many possible splits (e.g., continuous variables or categorical variables with many categories) over variables with fewer splits (the extreme case being binary variables, which have only one possible split).** Conditional inference trees (Hothorn, Hornik, and Zeileis 2006) implement an alternative splitting mechanism that helps to reduce this variable selection bias. However, ensembling conditional inference trees has yet to be proven superior with regards to predictive accuracy and they take a lot longer to train.

From <https://bradleyboehmke.github.io/HOML/random-forest.html>.

Our `PBE` flag is a binary variable, so is its importance being under-valued by `ranger`? Test a conditional inference tree-based forest:

```{r conditional-inference}
set.seed(123)
training <- sample(nrow(test), 0.9 * nrow(test), replace = FALSE)
m_ci <- cforest(sqrt_Rs_annual ~ ., data = test[training,])
message("Variable importance of CI forest:")
sort(varimp(m_ci), decreasing = TRUE)

obs <- test[-training,]$sqrt_Rs_annual
pred <- predict(m_ci, newdata = test[-training,])
rss <- sum((pred - obs) ^ 2)
tss <- sum((obs - mean(obs)) ^ 2)
message("R2 against validation data = ", round(1 - rss / tss, 3))
```

**Conclusion: no evidence that conditional inference random forest produces different results.**

## XGBoost

What about it?

```{r xgboost}
set.seed(123)
training <- sample(nrow(test), 0.9 * nrow(test), replace = FALSE)
m_xgb <- m <- xgboost(test[training,-1], test$sqrt_Rs_annual[training])

message("Variable importance of XGBoost model:")
as_tibble(xgb.importance(m_xgb))

obs <- test[-training,]$sqrt_Rs_annual
pred <- predict(m_xgb, newdata = test[-training,])
rss <- sum((pred - obs) ^ 2)
tss <- sum((obs - mean(obs)) ^ 2)
message("R2 against validation data = ", round(1 - rss / tss, 3))
```

Note however that

\>Unlike random forests, GBMs can have high variability in accuracy dependent on their hyperparameter settings (Probst, Bischl, and Boulesteix 2018). So tuning can require much more strategy than a random forest model.

**Conclusion: performance and variable importance seem similar to `ranger`.**

## Test spatial Random Forest

Spatial autocorrelation wouldn't change the fit of the model, but it could bias the variable importance metrics. Evaluate.

```{r spatial-rf}

# This needs the newest version 1.1.5, not yet on CRAN
# remotes::install_github(repo = "blasbenito/spatialRF",
#   ref = "main", force = TRUE, quiet = TRUE)
stopifnot(packageVersion("spatialRF") >= "1.1.5")

dat_filtered %>% 
    select(sqrt_Rs_annual, Longitude, Latitude,
           Ecosystem_type, SPEI12, #MODIS_NPP, MODIS_GPP,
           Tair:LAI_low, Soil_type_name) %>% 
    filter(complete.cases(.)) -> 
    test

# Compute distance between all pairs of points
dm <- geodist(select(test, Longitude, Latitude), measure = "geodesic")
test$Longitude <- test$Latitude <- NULL

rf_sp <- spatialRF::rf(data = test, 
                       dependent.variable.name = colnames(test)[1],
                       predictor.variable.names = setdiff(colnames(test), colnames(test)[1]),
                       distance.matrix = dm)
```

**Conclusion: no strong evidence of spatial autocorrelation.**

## Linear model: PBE importance and interactions

```{r test-linear}
#| fig-width: 10
#| fig-height: 6

dat_filtered %>% 
    mutate(PBE = SPEI12_y1 <= -1 & SPEI12 > 0,
           Ecosystem_type_number = as.numeric(Ecosystem_type)) %>% 
    select(sqrt_Rs_annual, 
           Ecosystem_type, Ecosystem_type_number, 
           SPEI12, PBE, 
           Tair, Tsoil_lev1, Tsoil_lev2,
           Precip, VWC_lev1, VWC_lev2, 
           Veg_type_hi, Veg_type_low, LAI_high, LAI_low,
           Soil_type_number) %>% 
    filter(complete.cases(.)) ->
    dat_linear

message("Fitting Rs_annual linear model with PBE (SPEI12, -1.0) effect...")
m_Rs <- lm(sqrt_Rs_annual ~ (Tair + Tsoil_lev1 + Tsoil_lev2 +
            VWC_lev1 + I(VWC_lev1 ^ 2) + VWC_lev2 ^ 2 + I(VWC_lev2 ^ 2)) * PBE +
            Ecosystem_type_number + LAI_high * LAI_low + 
            Veg_type_hi + Veg_type_low + Soil_type_number,
        data = dat_linear)
m_Rs_reduced <- MASS::stepAIC(m_Rs, trace = FALSE)
summary(m_Rs_reduced)
par(mfrow = c(2, 2))
plot(m_Rs_reduced)

car::Anova(m_Rs_reduced, type = "III")

message("Fitting Rs_annual linear model without PBE effect...")
m_Rs_no_PBE <- lm(sqrt_Rs_annual ~ (Tair + Tsoil_lev1 + Tsoil_lev2 +
            VWC_lev1 + I(VWC_lev1 ^ 2) + VWC_lev2 ^ 2 + I(VWC_lev2 ^ 2)) +
            Ecosystem_type_number + LAI_high * LAI_low + 
                Veg_type_hi + Veg_type_low + Soil_type_number,
        data = dat_linear)

tibble(model_with_PBE = predict(m_Rs),
       model_without_PBE = predict(m_Rs_no_PBE),
       PBE = dat_linear$PBE, 
       Ecosystem_type = dat_linear$Ecosystem_type) %>% 
    ggplot(aes(model_without_PBE, model_with_PBE)) + 
    geom_point(aes(color = PBE)) + 
    geom_abline() + 
    facet_wrap(~Ecosystem_type) +
    ggtitle("Linear model: effect of including PBE on sqrt_Rs_annual")

# Extract the significant interactions between PBE and other variables 
message("Interactive PBE effects:")
tidy(m_Rs_reduced) %>% 
    mutate(model = "Rs_annual") %>% 
    filter(grepl("PBE", term)) %>% 
    separate(term, into = c("interaction", "PBE"), fill = "left", sep = ":") %>% 
    replace_na(list(interaction = "(none)")) %>% 
    select(model, interaction, estimate, p.value) %>% 
    mutate(estimate = round(estimate, 4), p.value = round(p.value, 4)) ->
    PBE_interactions

DT::datatable(PBE_interactions)

# Summary table of significant effect directions
PBE_interactions %>% 
    mutate(signif = p.value < 0.05, 
           effect = case_when(signif & estimate < 0 ~ "Negative",
                              signif & estimate >= 0 ~ "Positive",
                              .default = "")) %>% 
    select(model, interaction, effect) %>%
    pivot_wider(values_from = effect, names_from = model, values_fill = "") %>% 
    knitr::kable(caption = "PBE: significant effect directions")

```

**Conclusions:**

-   **PBE (potential Birch effect, i.e. having a strong drought the year before a well-watered year) has a strong statistical effect on the temperature and moisture drivers of soil respiration.**

-   **But, it's inconsistent—there's no clean 'Birch effect.'\
    **

## PBE sensitivity test

```{r analysis1}

fit_and_test_lm <- function(x_train, x_val) {
    m <- lm(sqrt_Rs_annual ~ (Tair + Tsoil_lev1 + Tsoil_lev2 +
            VWC_lev1 + I(VWC_lev1 ^ 2) + VWC_lev2 ^ 2 + I(VWC_lev2 ^ 2)) * PBE +
            Ecosystem_type_number + LAI_high * LAI_low + 
            Veg_type_hi + Veg_type_low + Soil_type_number,
        data = x_train)
    m_reduced <- MASS::stepAIC(m, trace = FALSE)
    list(model = m_reduced,
         training_r2 = glance(m_reduced)$r.squared,
         importance = tidy(m_reduced))
}

# These are the three most common fluxes recorded in SRDB
#iv_set <- c("Rs_annual")#, "Rh_annual", "Rs_growingseason")
iv_set <- c("sqrt_Rs_annual", "sqrt_Rh_annual", "sqrt_Rs_growingseason")

# The following SPEI values are from Table 1 of Keune et al. (2025)
# https://www.nature.com/articles/s41597-025-04896-y
# and correspond to "severely dry", "moderately dry", and "mildly dry"
# (there are no "extremely dry"=-2 in the dataset)
spei_cutoffs <- c(-1.5, -1.0, 0.0)

# What SPEI window should be used for the cutoffs above?
spei_windows <- c(12, 24) # months

# Model independent variables
predictors <- c("Ecosystem_type",
                "SPEI12",
                "Tair", "Precip",
                "Tsoil_lev1", "Tsoil_lev2", "VWC_lev1", "VWC_lev2", 
                "Veg_type_hi", "Veg_type_low", 
                "LAI_high", "LAI_low", "Soil_type_name")

do_full_analysis <- function(x, iv_set, predictors, spei_windows, spei_cutoffs) {
    results <- list()
    SPEI_cols <- colnames(x)[grep("^SPEI", colnames(x))]
    for(iv in iv_set) {
        
        for(w in spei_windows) {
            spei_past_col <- paste0("SPEI", w, "_y1")
            
            for(spei_cut in spei_cutoffs) {
                # Remove other potential independent variables
                this_x <- x[c(iv, union(predictors, SPEI_cols))]
                # Complete cases only
                this_x <- this_x[complete.cases(this_x),]
                
                message("---------------------------------------------")
                message("iv = ", iv)
                message("spei_cut = ", spei_cut, " window = ", w)
                message("\tn = ", nrow(this_x))
                
                # identify observations not currently in a drought but that
                # WERE in a drought the previous year
                # PBE = potential Birch effect
                this_x$PBE = this_x$SPEI12 > 0 & this_x[spei_past_col] <= spei_cut
                message("\tPBE = ", sum(this_x$PBE))
                
                # Drop non-predictors entirely now
                this_x <- this_x[c(iv, predictors, "PBE")]
                
                # Fit models and save results
                rf_out <- fit_and_test_rf(this_x, NULL)
                rf_results <- tibble(spei_window = w,
                                     spei_cut = spei_cut,
                                     iv = iv,
                                     predictor = names(rf_out$importance),
                                     n = nrow(this_x),
                                     pbe_n = sum(this_x$PBE),
                                     importance = rf_out$importance,
                                     training_r2 = rf_out$training_r2)
                results[[paste(iv, w, spei_cut)]] <- rf_results

                # lm_out <- fit_and_test_lm(this_x, NULL)
                # lm_results <- tibble(spei_window = w,
                #                      spei_cut = spei_cut,
                #                      iv = iv,
                #                      predictor = names(rf_out$importance),
                #                      n = nrow(this_x),
                #                      pbe_n = sum(this_x$PBE),
                #                      training_r2 = lm_out$training_r2)
 
            }
        }
    }
    bind_rows(results)
}

out <- do_full_analysis(dat_filtered,
                        iv_set, predictors,
                        spei_windows = c(12,24),
                        spei_cutoffs = spei_cutoffs)

# Compute means across the SPEI windows, drought definitions, and i.v.'s
out %>% 
    group_by(spei_window, spei_cut, iv, n, pbe_n) %>% 
    summarise(r2 = round(mean(training_r2), 3), .groups = "drop") %>% 
    mutate(spei_cut = as.factor(spei_cut),
           spei_window = paste(spei_window, "months")) ->
    out_smry

```

## Random Forest results

```{r rf-results}


# Table: Training R2 values
out_smry %>%
    select(spei_window, spei_cut, iv, r2) %>% 
    pivot_wider(names_from = "iv", values_from = "r2") %>% 
    knitr::kable(caption = "RF training (OOB) R2")

# Table: number (and % of total) of TRUE PBE entries; how big are the datasets?
out_smry %>%
    mutate(pbe_n = paste0(pbe_n, " (", round(pbe_n / n * 100, 0), "%)")) %>% 
    select(spei_window, spei_cut, iv, pbe_n) %>% 
    pivot_wider(names_from = "iv", values_from = "pbe_n") %>% 
    knitr::kable(caption = "RF training PBE_N", align = "r")

# Table: rank of PBE variable
out %>% 
    group_by(spei_window, spei_cut, iv) %>% 
    mutate(rank = min_rank(desc(importance))) ->
    out_ranked

out_ranked %>% 
    filter(predictor == "PBE") %>% 
    select(spei_window, spei_cut, iv, rank) %>% 
    pivot_wider(names_from = "iv", values_from = "rank") %>%
    knitr::kable(caption = "Rank of PBE variable in RF model")

out_ranked %>% 
    group_by(iv, predictor) %>% summarise(rank = mean(rank)) %>% 
    ggplot(aes(iv, predictor, fill = rank)) + 
    geom_tile() + 
    xlab("Independent variable") +
    ggtitle("Predictor ranks in RF model")
```

**Conclusions:**

-   **The values used for SPEI window (12/24 months) and drought level (0, -1, -1.5) don't make much difference.**

-   **RF model explains 52-65% of OOB variability**

-   **Precip and Tair are uniformly important; LAI and soil temp/VWC medium importance; PBE (drought effect from previous year) not important**

## Reproducibility

```{r}
#| echo: false

sessionInfo()
```
